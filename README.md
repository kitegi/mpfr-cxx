lightweight wrapper around [gnu mpfr](https://www.mpfr.org/). allowing usage of stack allocated multiprecision floats.  
benefits over boost/multiprecision/mpfr:
  - scalar types are [trivially copyable](https://en.cppreference.com/w/cpp/named_req/TriviallyCopyable).
  - a possible value representation of positive zero is all zero bits. i.e., for an object `x` of type `mp_float_t<_>`, `std::memset(&x, 0, sizeof(x))`, will set `x` to `+0.0`.
  - optimized for certain common operations (for instance, multiplication and division by powers of two).
  - better `ostream` formatting support.
  - smaller compilation overhead.
 
disadvantages:
  - no support for operations involving floats of different precisions.

# usage
run `make_single_header.py` to generate a single header include file.

```cpp
#include "mpfr.hpp" // generated by python script
#include <iostream>

auto main() -> int {
  using mpfr::digits2;
  using mpfr::mp_float_t;
  using scalar_t = mp_float_t<digits2{4096}>;

  scalar_t x = 0;

  scalar_t n = 1000000;
  for (long i = 1; i <= n; ++i) {
    x += 1 / scalar_t{i};
  }

  // advanced usage with mpfr
  scalar_t y;

  // binds a mpfr_ptr proxy (yp) to y, and sets y to the corresponding value
  mpfr::handle_as_mpfr_t(
      [](mpfr_ptr yp) {
        mpfr_const_euler(yp, MPFR_RNDN); // lim n->âˆž sum(i in [1.. n]) 1/i
      },
      y);

  // compare sum with asymptotic approximation
  std::cout << (x - (y + log(n) + 1 / (2 * n) - 1 / (12 * n * n))) << '\n';
}
```
