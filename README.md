lightweight wrapper around [gnu mpfr](https://www.mpfr.org/). allowing usage of stack allocated multiprecision floats.  
reasons to use this over boost::multiprecision::mpfr:
  - scalar types are [trivially copyable](https://en.cppreference.com/w/cpp/named_req/TriviallyCopyable).
  - a possible value representation of positive zero is all zero bits. i.e., for an object `x` of type `mp_float_t<_>`, `std::memset(&x, 0, sizeof(x))`, will set `x` to `+0.0`.
  - optimized for certain common operations (for instance, multiplication and division by powers of two).
  - better `ostream` formatting support.
  - smaller compilation overhead.
 
# usage
run `make_single_header.py` to generate a single header include file.

```cpp
#include "mpfr.hpp" // generated by python script
#include <iostream>

using mpfr::digits2;
using mpfr::mp_float_t;
using scalar_t = mp_float_t<digits2{4096}>;

auto euler_mascheroni_constant() -> scalar_t {
  // advanced usage with mpfr
  scalar_t y;

  // binds a mpfr_ptr proxy (yp) to y, and sets y to the corresponding value
  mpfr::handle_as_mpfr_t(
      [](mpfr_ptr yp) {
        mpfr_const_euler(yp, MPFR_RNDN); // lim n->âˆž sum(i in [1.. n]) 1/i
      },
      y);
  return y;
}

auto main() -> int {

  scalar_t x = 0;

  scalar_t n{1000000};
  for (long i = 1; i <= n; ++i) {
    x += 1 / scalar_t{i};
  }

  auto y = euler_mascheroni_constant();
  std::cout << (x - (y + log(n) + 1 / (2 * n) - 1 / (12 * n * n))) << '\n';
}
```
